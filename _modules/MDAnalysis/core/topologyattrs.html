<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>MDAnalysis.core.topologyattrs &#8212; MDAnalysis 0.17.0-dev documentation</title>
    
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.17.0-dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within MDAnalysis 0.17.0-dev documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../../_static/mdanalysis-logo.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for MDAnalysis.core.topologyattrs</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-</span>
<span class="c1"># vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4 fileencoding=utf-8</span>
<span class="c1">#</span>
<span class="c1"># MDAnalysis --- http://www.mdanalysis.org</span>
<span class="c1"># Copyright (c) 2006-2017 The MDAnalysis Development Team and contributors</span>
<span class="c1"># (see the file AUTHORS for the full list of names)</span>
<span class="c1">#</span>
<span class="c1"># Released under the GNU Public Licence, v2 or any higher version</span>
<span class="c1">#</span>
<span class="c1"># Please cite your use of MDAnalysis in published work:</span>
<span class="c1">#</span>
<span class="c1"># R. J. Gowers, M. Linke, J. Barnoud, T. J. E. Reddy, M. N. Melo, S. L. Seyler,</span>
<span class="c1"># D. L. Dotson, J. Domanski, S. Buchoux, I. M. Kenney, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Python package for the rapid analysis of molecular dynamics</span>
<span class="c1"># simulations. In S. Benthall and S. Rostrup editors, Proceedings of the 15th</span>
<span class="c1"># Python in Science Conference, pages 102-109, Austin, TX, 2016. SciPy.</span>
<span class="c1">#</span>
<span class="c1"># N. Michaud-Agrawal, E. J. Denning, T. B. Woolf, and O. Beckstein.</span>
<span class="c1"># MDAnalysis: A Toolkit for the Analysis of Molecular Dynamics Simulations.</span>
<span class="c1"># J. Comput. Chem. 32 (2011), 2319--2327, doi:10.1002/jcc.21787</span>
<span class="c1">#</span>

<span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">Topology attribute objects --- :mod:`MDAnalysis.core.topologyattrs`</span>
<span class="sd">===================================================================</span>

<span class="sd">Common :class:`TopologyAttr` instances that are used by most topology</span>
<span class="sd">parsers.</span>

<span class="sd">TopologyAttrs are used to contain attributes such as atom names or resids.</span>
<span class="sd">These are usually read by the TopologyParser.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="nb">zip</span><span class="p">,</span> <span class="nb">range</span>

<span class="kn">import</span> <span class="nn">Bio.Seq</span>
<span class="kn">import</span> <span class="nn">Bio.SeqRecord</span>
<span class="kn">import</span> <span class="nn">Bio.Alphabet</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">numpy.lib.utils</span> <span class="k">import</span> <span class="n">deprecate</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">flags</span>
<span class="kn">from</span> <span class="nn">..lib.util</span> <span class="k">import</span> <span class="n">cached</span><span class="p">,</span> <span class="n">convert_aa_code</span><span class="p">,</span> <span class="n">iterable</span>
<span class="kn">from</span> <span class="nn">..lib</span> <span class="k">import</span> <span class="n">transformations</span><span class="p">,</span> <span class="n">mdamath</span>
<span class="kn">from</span> <span class="nn">..exceptions</span> <span class="k">import</span> <span class="n">NoDataError</span><span class="p">,</span> <span class="n">SelectionError</span>
<span class="kn">from</span> <span class="nn">.topologyobjects</span> <span class="k">import</span> <span class="n">TopologyGroup</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">selection</span>
<span class="kn">from</span> <span class="nn">.groups</span> <span class="k">import</span> <span class="p">(</span><span class="n">ComponentBase</span><span class="p">,</span> <span class="n">GroupBase</span><span class="p">,</span>
                     <span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">,</span> <span class="n">Segment</span><span class="p">,</span>
                     <span class="n">AtomGroup</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_length</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper which checks the length of inputs to set_X</span>

<span class="sd">    Eg:</span>

<span class="sd">    @_check_length</span>
<span class="sd">    def set_X(self, group, values):</span>

<span class="sd">    Will check the length of *values* compared to *group* before proceeding with</span>
<span class="sd">    anything in the *set_X* method.</span>

<span class="sd">    Pseudo code for the check:</span>

<span class="sd">    if group in (Atom, Residue, Segment):</span>
<span class="sd">        values must be single values, ie int, float or string</span>
<span class="sd">    else:</span>
<span class="sd">        values must be single value OR same length as group</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_SINGLE_VALUE_ERROR</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Setting </span><span class="si">{cls}</span><span class="s2"> </span><span class="si">{attrname}</span><span class="s2"> with wrong sized input. &quot;</span>
                           <span class="s2">&quot;Must use single value, length of supplied values: </span><span class="si">{lenvalues}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="c1"># Eg &quot;Setting Residue resid with wrong sized input. Must use single value, length of supplied</span>
    <span class="c1"># values: 2.&quot;</span>

    <span class="n">_GROUP_VALUE_ERROR</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Setting </span><span class="si">{group}</span><span class="s2"> </span><span class="si">{attrname}</span><span class="s2"> with wrong sized array. &quot;</span>
                          <span class="s2">&quot;Length </span><span class="si">{group}</span><span class="s2">: </span><span class="si">{lengroup}</span><span class="s2">, length of supplied values: </span><span class="si">{lenvalues}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="c1"># Eg &quot;Setting AtomGroup masses with wrong sized array. Length AtomGroup: 100, length of</span>
    <span class="c1"># supplied values: 50.&quot;</span>

    <span class="k">def</span> <span class="nf">_attr_len</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
        <span class="c1"># quasi len measurement</span>
        <span class="c1"># strings, floats, ints are len 0, ie not iterable</span>
        <span class="c1"># other iterables are just len&#39;d</span>
        <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>  <span class="c1"># special case</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">val_len</span> <span class="o">=</span> <span class="n">_attr_len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">ComponentBase</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">val_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_SINGLE_VALUE_ERROR</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">cls</span><span class="o">=</span><span class="n">group</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">attrname</span><span class="o">=</span><span class="n">attr</span><span class="o">.</span><span class="n">singular</span><span class="p">,</span>
                    <span class="n">lenvalues</span><span class="o">=</span><span class="n">val_len</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">val_len</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">val_len</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_GROUP_VALUE_ERROR</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">group</span><span class="o">=</span><span class="n">group</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">attrname</span><span class="o">=</span><span class="n">attr</span><span class="o">.</span><span class="n">attrname</span><span class="p">,</span>
                    <span class="n">lengroup</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">),</span> <span class="n">lenvalues</span><span class="o">=</span><span class="n">val_len</span><span class="p">))</span>
        <span class="c1"># if everything went OK, continue with the function</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span> <span class="nf">_wronglevel_error</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate an error for setting attr at wrong level</span>

<span class="sd">    attr : TopologyAttr that was accessed</span>
<span class="sd">    group : Offending Component/Group</span>

<span class="sd">    Eg:</span>
<span class="sd">    setting mass of residue, gets called with attr=Masses, group=residue</span>

<span class="sd">    raises a NotImplementedError with:</span>
<span class="sd">    &#39;Cannot set masses from Residue.  Use &#39;Residue.atoms.masses&#39;</span>

<span class="sd">    Mainly used to ensure consistent and helpful error messages</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Atom</span><span class="p">,</span> <span class="n">AtomGroup</span><span class="p">)):</span>
        <span class="n">group_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Residue</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">)):</span>
        <span class="n">group_level</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Segment</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">)):</span>
        <span class="n">group_level</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="c1"># What level to go to before trying to set this attr</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">AtomAttr</span><span class="p">):</span>
        <span class="n">corr_classes</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;atoms&#39;</span><span class="p">,</span> <span class="s1">&#39;atom&#39;</span><span class="p">)</span>
        <span class="n">attr_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">ResidueAttr</span><span class="p">):</span>
        <span class="n">corr_classes</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;residues&#39;</span><span class="p">,</span> <span class="s1">&#39;residue&#39;</span><span class="p">)</span>
        <span class="n">attr_level</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">SegmentAttr</span><span class="p">):</span>
        <span class="n">corr_classes</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;segments&#39;</span><span class="p">,</span> <span class="s1">&#39;segment&#39;</span><span class="p">)</span>
        <span class="n">attr_level</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">ComponentBase</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">attr_level</span> <span class="o">&gt;</span> <span class="n">group_level</span><span class="p">):</span>
        <span class="c1"># ie going downards use plurals, going upwards use singulars</span>
        <span class="c1"># Residue.atom!s!.mass!es! but Atom.segment!!.segid!!</span>
        <span class="n">correct</span> <span class="o">=</span> <span class="n">corr_classes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">attrname</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">singular</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">correct</span> <span class="o">=</span> <span class="n">corr_classes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">attrname</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">attrname</span>

    <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;Cannot set </span><span class="si">{attr}</span><span class="s2"> from </span><span class="si">{cls}</span><span class="s2">. Use &#39;</span><span class="si">{cls}</span><span class="s2">.</span><span class="si">{correct}</span><span class="s2">.</span><span class="si">{attr}</span><span class="s2"> = &#39;&quot;</span>
    <span class="c1"># eg &quot;Cannot set masses from Residue.  &#39;Use Residue.atoms.masses = &#39;&quot;</span>

    <span class="k">return</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">err_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">attr</span><span class="o">=</span><span class="n">attrname</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">group</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">correct</span><span class="o">=</span><span class="n">correct</span><span class="p">,</span>
    <span class="p">))</span>


<div class="viewcode-block" id="TopologyAttr"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr">[docs]</a><span class="k">class</span> <span class="nc">TopologyAttr</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for Topology attributes.</span>

<span class="sd">    .. note::   This class is intended to be subclassed, and mostly amounts to</span>
<span class="sd">                a skeleton. The methods here should be present in all</span>
<span class="sd">                :class:`TopologyAttr` child classes, but by default they raise</span>
<span class="sd">                appropriate exceptions.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    attrname : str</span>
<span class="sd">        the name used for the attribute when attached to a ``Topology`` object</span>
<span class="sd">    singular : str</span>
<span class="sd">        name for the attribute on a singular object (Atom/Residue/Segment)</span>
<span class="sd">    per_object : str</span>
<span class="sd">        If there is a strict mapping between Component and Attribute</span>
<span class="sd">    top : Topology</span>
<span class="sd">        handle for the Topology object TopologyAttr is associated with</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;topologyattrs&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;topologyattr&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># ie Resids per_object = &#39;residue&#39;</span>
    <span class="n">top</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># pointer to Topology object</span>

    <span class="n">groupdoc</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">singledoc</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span> <span class="o">=</span> <span class="n">guessed</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Length of the TopologyAttr at its intrinsic level.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Accepts an AtomGroup, ResidueGroup or SegmentGroup&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Atom</span><span class="p">,</span> <span class="n">AtomGroup</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_atoms</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Residue</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_residues</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Segment</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_segments</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Atom</span><span class="p">,</span> <span class="n">AtomGroup</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_atoms</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Residue</span><span class="p">,</span> <span class="n">ResidueGroup</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_residues</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="n">Segment</span><span class="p">,</span> <span class="n">SegmentGroup</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_segments</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_guessed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Bool of if the source of this information is a guess&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span>

<div class="viewcode-block" id="TopologyAttr.get_atoms"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr.get_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">get_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get atom attributes for a given AtomGroup&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">NoDataError</span></div>

<div class="viewcode-block" id="TopologyAttr.set_atoms"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr.set_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">set_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set atom attributes for a given AtomGroup&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="TopologyAttr.get_residues"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr.get_residues">[docs]</a>    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get residue attributes for a given ResidueGroup&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">NoDataError</span></div>

<div class="viewcode-block" id="TopologyAttr.set_residues"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr.set_residues">[docs]</a>    <span class="k">def</span> <span class="nf">set_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set residue attributes for a given ResidueGroup&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="TopologyAttr.get_segments"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr.get_segments">[docs]</a>    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get segment attributes for a given SegmentGroup&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">NoDataError</span></div>

<div class="viewcode-block" id="TopologyAttr.set_segments"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.TopologyAttr.set_segments">[docs]</a>    <span class="k">def</span> <span class="nf">set_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set segmentattributes for a given SegmentGroup&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div></div>


<span class="c1"># core attributes</span>

<div class="viewcode-block" id="Atomindices"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomindices">[docs]</a><span class="k">class</span> <span class="nc">Atomindices</span><span class="p">(</span><span class="n">TopologyAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Globally unique indices for each atom in the group.</span>

<span class="sd">    If the group is an AtomGroup, then this gives the index for each atom in</span>
<span class="sd">    the group. This is the unambiguous identifier for each atom in the</span>
<span class="sd">    topology, and it is not alterable.</span>

<span class="sd">    If the group is a ResidueGroup or SegmentGroup, then this gives the indices</span>
<span class="sd">    of each atom represented in the group in a 1-D array, in the order of the</span>
<span class="sd">    elements in that group.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;indices&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;index&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Atom</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">set_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Atom indices are fixed; they cannot be reset&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ag</span><span class="o">.</span><span class="n">_ix</span>

    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">residues2atoms_2d</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">_ix</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">segments2atoms_2d</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">_ix</span><span class="p">))</span></div>


<div class="viewcode-block" id="Resindices"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Resindices">[docs]</a><span class="k">class</span> <span class="nc">Resindices</span><span class="p">(</span><span class="n">TopologyAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Globally unique resindices for each residue in the group.</span>

<span class="sd">    If the group is an AtomGroup, then this gives the resindex for each atom in</span>
<span class="sd">    the group. This unambiguously determines each atom&#39;s residue membership.</span>
<span class="sd">    Resetting these values changes the residue membership of the atoms.</span>

<span class="sd">    If the group is a ResidueGroup or SegmentGroup, then this gives the</span>
<span class="sd">    resindices of each residue represented in the group in a 1-D array, in the</span>
<span class="sd">    order of the elements in that group.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;resindices&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;resindex&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">get_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">atoms2residues</span><span class="p">(</span><span class="n">ag</span><span class="o">.</span><span class="n">_ix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">rg</span><span class="o">.</span><span class="n">_ix</span>

    <span class="k">def</span> <span class="nf">set_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Residue indices are fixed; they cannot be reset&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">segments2residues_2d</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">_ix</span><span class="p">))</span></div>


<div class="viewcode-block" id="Segindices"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Segindices">[docs]</a><span class="k">class</span> <span class="nc">Segindices</span><span class="p">(</span><span class="n">TopologyAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Globally unique segindices for each segment in the group.</span>

<span class="sd">    If the group is an AtomGroup, then this gives the segindex for each atom in</span>
<span class="sd">    the group. This unambiguously determines each atom&#39;s segment membership.</span>
<span class="sd">    It is not possible to set these, since membership in a segment is an</span>
<span class="sd">    attribute of each atom&#39;s residue.</span>

<span class="sd">    If the group is a ResidueGroup or SegmentGroup, then this gives the</span>
<span class="sd">    segindices of each segment represented in the group in a 1-D array, in the</span>
<span class="sd">    order of the elements in that group.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;segindices&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;segindex&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">,</span> <span class="n">Segment</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">get_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">atoms2segments</span><span class="p">(</span><span class="n">ag</span><span class="o">.</span><span class="n">_ix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">residues2segments</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">_ix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sg</span><span class="o">.</span><span class="n">_ix</span>

    <span class="k">def</span> <span class="nf">set_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Segment indices are fixed; they cannot be reset&quot;</span><span class="p">)</span></div>


<span class="c1"># atom attributes</span>

<div class="viewcode-block" id="AtomAttr"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.AtomAttr">[docs]</a><span class="k">class</span> <span class="nc">AtomAttr</span><span class="p">(</span><span class="n">TopologyAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for atom attributes.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;atomattrs&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;atomattr&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Atom</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">ag</span><span class="o">.</span><span class="n">_ix</span><span class="p">]</span>

    <span class="nd">@_check_length</span>
    <span class="k">def</span> <span class="nf">set_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">ag</span><span class="o">.</span><span class="n">_ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>

<div class="viewcode-block" id="AtomAttr.get_residues"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.AtomAttr.get_residues">[docs]</a>    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;By default, the values for each atom present in the set of residues</span>
<span class="sd">        are returned in a single array. This behavior can be overriden in child</span>
<span class="sd">        attributes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aixs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">residues2atoms_2d</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">_ix</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">aix</span><span class="p">]</span> <span class="k">for</span> <span class="n">aix</span> <span class="ow">in</span> <span class="n">aixs</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">set_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">_wronglevel_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">)</span>

<div class="viewcode-block" id="AtomAttr.get_segments"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.AtomAttr.get_segments">[docs]</a>    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;By default, the values for each atom present in the set of residues</span>
<span class="sd">        are returned in a single array. This behavior can be overriden in child</span>
<span class="sd">        attributes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aixs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">segments2atoms_2d</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">_ix</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">aix</span><span class="p">]</span> <span class="k">for</span> <span class="n">aix</span> <span class="ow">in</span> <span class="n">aixs</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">set_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">_wronglevel_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">)</span></div>


<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Atomids"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomids">[docs]</a><span class="k">class</span> <span class="nc">Atomids</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;ID for each atom.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;ids&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;id&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span></div>


<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Atomnames"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomnames">[docs]</a><span class="k">class</span> <span class="nc">Atomnames</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Name for each atom.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;names&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;name&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getattr__</span><span class="p">(</span><span class="n">atomgroup</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">_get_named_atom</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">selection</span><span class="o">.</span><span class="n">SelectionError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{0}</span><span class="s2">&#39; object has no attribute &#39;</span><span class="si">{1}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">atomgroup</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_named_atom</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get all atoms with name *name* in the current AtomGroup.</span>

<span class="sd">        For more than one atom it returns a list of :class:`Atom`</span>
<span class="sd">        instance. A single :class:`Atom` is returned just as such. If</span>
<span class="sd">        no atoms are found, a :exc:`SelectionError` is raised.</span>

<span class="sd">        .. versionadded:: 0.9.2</span>

<span class="sd">        .. deprecated:: 0.16.2</span>
<span class="sd">           *Instant selectors* will be removed in the 1.0 release.</span>
<span class="sd">           Use ``AtomGroup.select_atoms(&#39;name &lt;name&gt;&#39;)`` instead.</span>
<span class="sd">           See issue `#1377</span>
<span class="sd">           &lt;https://github.com/MDAnalysis/mdanalysis/issues/1377&gt;`_ for</span>
<span class="sd">           more details.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># There can be more than one atom with the same name</span>
        <span class="n">atomlist</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">unique</span><span class="p">[</span><span class="n">group</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">unique</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atomlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">selection</span><span class="o">.</span><span class="n">SelectionError</span><span class="p">(</span>
                <span class="s2">&quot;No atoms with name &#39;</span><span class="si">{0}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">atomlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># XXX: keep this, makes more sense for names</span>
            <span class="n">atomlist</span> <span class="o">=</span> <span class="n">atomlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Instant selector AtomGroup[&#39;&lt;name&gt;&#39;] or AtomGroup.&lt;name&gt; &quot;</span>
                      <span class="s2">&quot;is deprecated and will be removed in 1.0. &quot;</span>
                      <span class="s2">&quot;Use AtomGroup.select_atoms(&#39;name &lt;name&gt;&#39;) instead.&quot;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">atomlist</span>

    <span class="c1"># AtomGroup already has a getattr</span>
<span class="c1">#    transplants[AtomGroup].append(</span>
<span class="c1">#        (&#39;__getattr__&#39;, getattr__))</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">Residue</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;__getattr__&#39;</span><span class="p">,</span> <span class="n">getattr__</span><span class="p">))</span>

    <span class="c1"># this is also getitem for a residue</span>
    <span class="n">transplants</span><span class="p">[</span><span class="n">Residue</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;__getitem__&#39;</span><span class="p">,</span> <span class="n">getattr__</span><span class="p">))</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">AtomGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;_get_named_atom&#39;</span><span class="p">,</span> <span class="n">_get_named_atom</span><span class="p">))</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">Residue</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;_get_named_atom&#39;</span><span class="p">,</span> <span class="n">_get_named_atom</span><span class="p">))</span>

<div class="viewcode-block" id="Atomnames.phi_selection"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomnames.phi_selection">[docs]</a>    <span class="k">def</span> <span class="nf">phi_selection</span><span class="p">(</span><span class="n">residue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;AtomGroup corresponding to the phi protein backbone dihedral</span>
<span class="sd">        C&#39;-N-CA-C.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        AtomGroup</span>
<span class="sd">            4-atom selection in the correct order. If no C&#39; found in the</span>
<span class="sd">            previous residue (by resid) then this method returns ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: maybe this can be reformulated into one selection string without</span>
        <span class="c1"># the additions later</span>
        <span class="n">sel_str</span> <span class="o">=</span> <span class="s2">&quot;segid </span><span class="si">{}</span><span class="s2"> and resid </span><span class="si">{}</span><span class="s2"> and name C&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">residue</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">segid</span><span class="p">,</span> <span class="n">residue</span><span class="o">.</span><span class="n">resid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">sel_str</span><span class="p">)</span> <span class="o">+</span>
               <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s1">&#39;name N&#39;</span><span class="p">,</span> <span class="s1">&#39;name CA&#39;</span><span class="p">,</span> <span class="s1">&#39;name C&#39;</span><span class="p">))</span>

        <span class="c1"># select_atoms doesnt raise errors if nothing found, so check size</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

    <span class="n">transplants</span><span class="p">[</span><span class="n">Residue</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;phi_selection&#39;</span><span class="p">,</span> <span class="n">phi_selection</span><span class="p">))</span>

<div class="viewcode-block" id="Atomnames.psi_selection"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomnames.psi_selection">[docs]</a>    <span class="k">def</span> <span class="nf">psi_selection</span><span class="p">(</span><span class="n">residue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;AtomGroup corresponding to the psi protein backbone dihedral</span>
<span class="sd">        N-CA-C-N&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        AtomGroup</span>
<span class="sd">            4-atom selection in the correct order. If no N&#39; found in the</span>
<span class="sd">            following residue (by resid) then this method returns ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sel_str</span> <span class="o">=</span> <span class="s2">&quot;segid </span><span class="si">{}</span><span class="s2"> and resid </span><span class="si">{}</span><span class="s2"> and name N&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">residue</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">segid</span><span class="p">,</span> <span class="n">residue</span><span class="o">.</span><span class="n">resid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">sel</span> <span class="o">=</span> <span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s1">&#39;name N&#39;</span><span class="p">,</span> <span class="s1">&#39;name CA&#39;</span><span class="p">,</span> <span class="s1">&#39;name C&#39;</span><span class="p">)</span> <span class="o">+</span>
               <span class="n">residue</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="n">sel_str</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

    <span class="n">transplants</span><span class="p">[</span><span class="n">Residue</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;psi_selection&#39;</span><span class="p">,</span> <span class="n">psi_selection</span><span class="p">))</span>

<div class="viewcode-block" id="Atomnames.omega_selection"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomnames.omega_selection">[docs]</a>    <span class="k">def</span> <span class="nf">omega_selection</span><span class="p">(</span><span class="n">residue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;AtomGroup corresponding to the omega protein backbone dihedral</span>
<span class="sd">        CA-C-N&#39;-CA&#39;.</span>

<span class="sd">        omega describes the -C-N- peptide bond. Typically, it is trans (180</span>
<span class="sd">        degrees) although cis-bonds (0 degrees) are also occasionally observed</span>
<span class="sd">        (especially near Proline).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        AtomGroup</span>
<span class="sd">            4-atom selection in the correct order. If no C&#39; found in the</span>
<span class="sd">            previous residue (by resid) then this method returns ``None``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nextres</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">resid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">segid</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">segid</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s1">&#39;name CA&#39;</span><span class="p">,</span> <span class="s1">&#39;name C&#39;</span><span class="p">)</span> <span class="o">+</span>
               <span class="n">residue</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span>
                   <span class="s1">&#39;segid </span><span class="si">{}</span><span class="s1"> and resid </span><span class="si">{}</span><span class="s1"> and name N&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">segid</span><span class="p">,</span> <span class="n">nextres</span><span class="p">),</span>
                   <span class="s1">&#39;segid </span><span class="si">{}</span><span class="s1"> and resid </span><span class="si">{}</span><span class="s1"> and name CA&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">segid</span><span class="p">,</span> <span class="n">nextres</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

    <span class="n">transplants</span><span class="p">[</span><span class="n">Residue</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;omega_selection&#39;</span><span class="p">,</span> <span class="n">omega_selection</span><span class="p">))</span>

<div class="viewcode-block" id="Atomnames.chi1_selection"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomnames.chi1_selection">[docs]</a>    <span class="k">def</span> <span class="nf">chi1_selection</span><span class="p">(</span><span class="n">residue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;AtomGroup corresponding to the chi1 sidechain dihedral N-CA-CB-CG.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        AtomGroup</span>
<span class="sd">            4-atom selection in the correct order. If no CB and/or CG is found</span>
<span class="sd">            then this method returns ``None``.</span>

<span class="sd">        .. versionadded:: 0.7.5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ag</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s1">&#39;name N&#39;</span><span class="p">,</span> <span class="s1">&#39;name CA&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;name CB&#39;</span><span class="p">,</span> <span class="s1">&#39;name CG&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ag</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ag</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

    <span class="n">transplants</span><span class="p">[</span><span class="n">Residue</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;chi1_selection&#39;</span><span class="p">,</span> <span class="n">chi1_selection</span><span class="p">))</span></div>


<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Atomtypes"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Atomtypes">[docs]</a><span class="k">class</span> <span class="nc">Atomtypes</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Type for each atom&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;types&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;type&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span></div>


<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Elements"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Elements">[docs]</a><span class="k">class</span> <span class="nc">Elements</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Element for each atom&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;elements&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;element&#39;</span></div>


<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Radii"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Radii">[docs]</a><span class="k">class</span> <span class="nc">Radii</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Radii for each atom&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;radii&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;radius&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span></div>


<div class="viewcode-block" id="ChainIDs"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.ChainIDs">[docs]</a><span class="k">class</span> <span class="nc">ChainIDs</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;ChainID per atom</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This is an attribute of the Atom, not Residue or Segment</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;chainIDs&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;chainID&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span></div>


<div class="viewcode-block" id="Tempfactors"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Tempfactors">[docs]</a><span class="k">class</span> <span class="nc">Tempfactors</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Tempfactor for atoms&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;tempfactors&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;tempfactor&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span></div>


<span class="k">class</span> <span class="nc">Masses</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;masses&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;mass&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">,</span> <span class="n">Segment</span><span class="p">]</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="n">groupdoc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Mass of each component in the Group.</span>

<span class="s2">    If the Group is an AtomGroup, then the masses are for each atom. If the</span>
<span class="s2">    Group is a ResidueGroup or SegmentGroup, the masses are for each residue or</span>
<span class="s2">    segment, respectively. These are obtained by summation of the member atoms</span>
<span class="s2">    for each component.</span>
<span class="s2">    &quot;&quot;&quot;</span>

    <span class="n">singledoc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Mass of the component.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span> <span class="o">=</span> <span class="n">guessed</span>

    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="n">resatoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">residues2atoms_2d</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">_ix</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">_ix</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="c1"># for a single residue</span>
            <span class="n">masses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">resatoms</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># for a residuegroup</span>
            <span class="n">masses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rg</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">resatoms</span><span class="p">):</span>
                <span class="n">masses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">masses</span>

    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
        <span class="n">segatoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">segments2atoms_2d</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">_ix</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">_ix</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="c1"># for a single segment</span>
            <span class="n">masses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">segatoms</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># for a segmentgroup</span>
            <span class="n">masses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">segatoms</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">masses</span>

    <span class="k">def</span> <span class="nf">center_of_mass</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Center of mass of the Group.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pbc : bool, optional</span>
<span class="sd">            If ``True``, move all atoms within the primary unit cell before</span>
<span class="sd">            calculation. [``False``]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        center : ndarray</span>
<span class="sd">            center of group given masses as weights</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">            The :class:`MDAnalysis.core.flags` flag *use_pbc* when set to</span>
<span class="sd">            ``True`` allows the *pbc* flag to be used by default.</span>

<span class="sd">        .. versionchanged:: 0.8 Added `pbc` parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="n">group</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">masses</span><span class="p">,</span>
                                  <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">)</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;center_of_mass&#39;</span><span class="p">,</span> <span class="n">center_of_mass</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">total_mass</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total mass of the Group.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">group</span><span class="o">.</span><span class="n">masses</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;total_mass&#39;</span><span class="p">,</span> <span class="n">total_mass</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">moment_of_inertia</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tensor moment of inertia relative to center of mass as 3x3 numpy</span>
<span class="sd">        array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pbc : bool, optional</span>
<span class="sd">            If ``True``, move all atoms within the primary unit cell before</span>
<span class="sd">            calculation. [``False``]</span>

<span class="sd">        .. note::</span>
<span class="sd">            The :class:`MDAnalysis.core.flags` flag *use_pbc* when set to</span>
<span class="sd">            ``True`` allows the *pbc* flag to be used by default.</span>

<span class="sd">        .. versionchanged:: 0.8 Added *pbc* keyword</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomgroup</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">pbc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;pbc&#39;</span><span class="p">,</span> <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;use_pbc&#39;</span><span class="p">])</span>

        <span class="c1"># Convert to local coordinates</span>
        <span class="n">com</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">pack_into_box</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="n">com</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">com</span>

        <span class="n">masses</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">masses</span>
        <span class="c1"># Create the inertia tensor</span>
        <span class="c1"># m_i = mass of atom i</span>
        <span class="c1"># (x_i, y_i, z_i) = pos of atom i</span>
        <span class="c1"># Ixx = sum(m_i*(y_i^2+z_i^2));</span>
        <span class="c1"># Iyy = sum(m_i*(x_i^2+z_i^2));</span>
        <span class="c1"># Izz = sum(m_i*(x_i^2+y_i^2))</span>
        <span class="c1"># Ixy = Iyx = -1*sum(m_i*x_i*y_i)</span>
        <span class="c1"># Ixz = Izx = -1*sum(m_i*x_i*z_i)</span>
        <span class="c1"># Iyz = Izy = -1*sum(m_i*y_i*z_i)</span>
        <span class="n">tens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="c1"># xx</span>
        <span class="n">tens</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1"># xy &amp; yx</span>
        <span class="n">tens</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tens</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1"># xz &amp; zx</span>
        <span class="n">tens</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tens</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1"># yy</span>
        <span class="n">tens</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1"># yz + zy</span>
        <span class="n">tens</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tens</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1"># zz</span>
        <span class="n">tens</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">tens</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;moment_of_inertia&#39;</span><span class="p">,</span> <span class="n">moment_of_inertia</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">radius_of_gyration</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Radius of gyration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pbc : bool, optional</span>
<span class="sd">            If ``True``, move all atoms within the primary unit cell before</span>
<span class="sd">            calculation. [``False``]</span>

<span class="sd">        .. note::</span>
<span class="sd">            The :class:`MDAnalysis.core.flags` flag *use_pbc* when set to</span>
<span class="sd">            ``True`` allows the *pbc* flag to be used by default.</span>

<span class="sd">        .. versionchanged:: 0.8 Added *pbc* keyword</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomgroup</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">pbc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;pbc&#39;</span><span class="p">,</span> <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;use_pbc&#39;</span><span class="p">])</span>
        <span class="n">masses</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">masses</span>

        <span class="n">com</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="n">recenteredpos</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">pack_into_box</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="n">com</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">recenteredpos</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">com</span>

        <span class="n">rog_sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">masses</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">recenteredpos</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                                        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">total_mass</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rog_sq</span><span class="p">)</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;radius_of_gyration&#39;</span><span class="p">,</span> <span class="n">radius_of_gyration</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">shape_parameter</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shape parameter.</span>

<span class="sd">        See [Dima2004]_ for background information.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pbc : bool, optional</span>
<span class="sd">            If ``True``, move all atoms within the primary unit cell before</span>
<span class="sd">            calculation. [``False``]</span>

<span class="sd">        .. note::</span>
<span class="sd">            The :class:`MDAnalysis.core.flags` flag *use_pbc* when set to</span>
<span class="sd">            ``True`` allows the *pbc* flag to be used by default.</span>

<span class="sd">        .. [Dima2004] Dima, R. I., &amp; Thirumalai, D. (2004). Asymmetry in the</span>
<span class="sd">                  shapes of folded and denatured states of proteins. *J</span>
<span class="sd">                  Phys Chem B*, 108(21),</span>
<span class="sd">                  6564-6570. doi:`10.1021/jp037128y`_</span>

<span class="sd">        .. versionadded:: 0.7.7</span>
<span class="sd">        .. versionchanged:: 0.8 Added *pbc* keyword</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomgroup</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">pbc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;pbc&#39;</span><span class="p">,</span> <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;use_pbc&#39;</span><span class="p">])</span>
        <span class="n">masses</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">masses</span>

        <span class="n">com</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="n">recenteredpos</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">pack_into_box</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="n">com</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">recenteredpos</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span> <span class="n">com</span>
        <span class="n">tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">recenteredpos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">tensor</span> <span class="o">+=</span> <span class="n">masses</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">recenteredpos</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="p">:],</span>
                                           <span class="n">recenteredpos</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">tensor</span> <span class="o">/=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">total_mass</span><span class="p">()</span>
        <span class="n">eig_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="mf">27.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">eig_vals</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">shape</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;shape_parameter&#39;</span><span class="p">,</span> <span class="n">shape_parameter</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">asphericity</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Asphericity.</span>

<span class="sd">        See [Dima2004]_ for background information.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pbc : bool, optional</span>
<span class="sd">            If ``True``, move all atoms within the primary unit cell before</span>
<span class="sd">            calculation. If ``None`` use value defined in</span>
<span class="sd">            MDAnalysis.core.flags[&#39;use_pbc&#39;]</span>

<span class="sd">        .. note::</span>
<span class="sd">            The :class:`MDAnalysis.core.flags` flag *use_pbc* when set to</span>
<span class="sd">            ``True`` allows the *pbc* flag to be used by default.</span>

<span class="sd">        .. [Dima2004] Dima, R. I., &amp; Thirumalai, D. (2004). Asymmetry in the</span>
<span class="sd">                  shapes of folded and denatured states of proteins. *J</span>
<span class="sd">                  Phys Chem B*, 108(21),</span>
<span class="sd">                  6564-6570. doi:`10.1021/jp037128y`_</span>

<span class="sd">        .. versionadded:: 0.7.7</span>
<span class="sd">        .. versionchanged:: 0.8 Added *pbc* keyword</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomgroup</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span>
        <span class="k">if</span> <span class="n">pbc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pbc</span> <span class="o">=</span> <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;use_pbc&#39;</span><span class="p">]</span>
        <span class="n">masses</span> <span class="o">=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">masses</span>

        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="n">recenteredpos</span> <span class="o">=</span> <span class="p">(</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">pack_into_box</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span>
                             <span class="n">atomgroup</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">recenteredpos</span> <span class="o">=</span> <span class="p">(</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">positions</span> <span class="o">-</span>
                             <span class="n">atomgroup</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

        <span class="n">tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">recenteredpos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">tensor</span> <span class="o">+=</span> <span class="n">masses</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">recenteredpos</span><span class="p">[</span><span class="n">x</span><span class="p">],</span>
                                           <span class="n">recenteredpos</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>

        <span class="n">tensor</span> <span class="o">/=</span> <span class="n">atomgroup</span><span class="o">.</span><span class="n">total_mass</span><span class="p">()</span>
        <span class="n">eig_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.0</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">eig_vals</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">eig_vals</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">shape</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;asphericity&#39;</span><span class="p">,</span> <span class="n">asphericity</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">principal_axes</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the principal axes from the moment of inertia.</span>

<span class="sd">        e1,e2,e3 = AtomGroup.principal_axes()</span>

<span class="sd">        The eigenvectors are sorted by eigenvalue, i.e. the first one</span>
<span class="sd">        corresponds to the highest eigenvalue and is thus the first principal</span>
<span class="sd">        axes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pbc : bool, optional</span>
<span class="sd">            If ``True``, move all atoms within the primary unit cell before</span>
<span class="sd">            calculation. If ``None`` use value defined in setup flags.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The :class:`MDAnalysis.core.flags` flag *use_pbc* when set to</span>
<span class="sd">            ``True`` allows the *pbc* flag to be used by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        axis_vectors : array</span>
<span class="sd">            3 x 3 array with ``v[0]`` as first, ``v[1]`` as second, and</span>
<span class="sd">            ``v[2]`` as third eigenvector.</span>

<span class="sd">        .. versionchanged:: 0.8 Added *pbc* keyword</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomgroup</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">atoms</span>
        <span class="k">if</span> <span class="n">pbc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pbc</span> <span class="o">=</span> <span class="n">flags</span><span class="p">[</span><span class="s1">&#39;use_pbc&#39;</span><span class="p">]</span>
        <span class="n">e_val</span><span class="p">,</span> <span class="n">e_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">atomgroup</span><span class="o">.</span><span class="n">moment_of_inertia</span><span class="p">(</span><span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">))</span>

        <span class="c1"># Sort</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">e_val</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Return transposed in more logical form. See Issue 33.</span>
        <span class="k">return</span> <span class="n">e_vec</span><span class="p">[:,</span> <span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;principal_axes&#39;</span><span class="p">,</span> <span class="n">principal_axes</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">align_principal_axis</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Align principal axis with index `axis` with `vector`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0, 1, 2}</span>
<span class="sd">            Index of the principal axis (0, 1, or 2), as produced by</span>
<span class="sd">            :meth:`~principal_axes`.</span>
<span class="sd">        vector : array_like</span>
<span class="sd">            Vector to align principal axis with.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        To align the long axis of a channel (the first principal axis, i.e.</span>
<span class="sd">        *axis* = 0) with the z-axis::</span>

<span class="sd">          u.atoms.align_principal_axis(0, [0,0,1])</span>
<span class="sd">          u.atoms.write(&quot;aligned.pdb&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">principal_axes</span><span class="p">()[</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">mdamath</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">vector</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">transformations</span><span class="o">.</span><span class="n">rotaxis</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">vector</span><span class="p">)</span>
        <span class="c1"># print &quot;principal[%d] = %r&quot; % (axis, p)</span>
        <span class="c1"># print &quot;axis = %r, angle = %f deg&quot; % (ax, angle)</span>
        <span class="k">return</span> <span class="n">group</span><span class="o">.</span><span class="n">rotateby</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;align_principal_axis&#39;</span><span class="p">,</span> <span class="n">align_principal_axis</span><span class="p">))</span>


<span class="c1"># TODO: update docs to property doc</span>
<span class="k">class</span> <span class="nc">Charges</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;charges&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;charge&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">,</span> <span class="n">Segment</span><span class="p">]</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="n">resatoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">residues2atoms_2d</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">_ix</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">_ix</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="n">charges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">resatoms</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">charges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rg</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">resatoms</span><span class="p">):</span>
                <span class="n">charges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">charges</span>

    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
        <span class="n">segatoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">segments2atoms_2d</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">_ix</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">_ix</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="c1"># for a single segment</span>
            <span class="n">charges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">segatoms</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># for a segmentgroup</span>
            <span class="n">charges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">segatoms</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">charges</span>

    <span class="k">def</span> <span class="nf">total_charge</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total charge of the Group.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">group</span><span class="o">.</span><span class="n">charges</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">GroupBase</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;total_charge&#39;</span><span class="p">,</span> <span class="n">total_charge</span><span class="p">))</span>


<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Bfactors"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Bfactors">[docs]</a><span class="k">class</span> <span class="nc">Bfactors</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Crystallographic B-factors in A**2 for each atom&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;bfactors&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;bfactor&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span></div>


<span class="c1"># TODO: update docs to property doc</span>
<span class="k">class</span> <span class="nc">Occupancies</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;occupancies&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;occupancy&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span>


<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="AltLocs"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.AltLocs">[docs]</a><span class="k">class</span> <span class="nc">AltLocs</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;AltLocs for each atom&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;altLocs&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;altLoc&#39;</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;atom&#39;</span></div>


<span class="c1"># residue attributes</span>

<div class="viewcode-block" id="ResidueAttr"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.ResidueAttr">[docs]</a><span class="k">class</span> <span class="nc">ResidueAttr</span><span class="p">(</span><span class="n">TopologyAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for Topology attributes.</span>

<span class="sd">    .. note::   This class is intended to be subclassed, and mostly amounts to</span>
<span class="sd">                a skeleton. The methods here should be present in all</span>
<span class="sd">                :class:`TopologyAttr` child classes, but by default they raise</span>
<span class="sd">                appropriate exceptions.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;residueattrs&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;residueattr&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Residue</span><span class="p">]</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;residue&#39;</span>

    <span class="k">def</span> <span class="nf">get_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="n">rix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">atoms2residues</span><span class="p">(</span><span class="n">ag</span><span class="o">.</span><span class="n">_ix</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">rix</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">set_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">_wronglevel_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">rg</span><span class="o">.</span><span class="n">_ix</span><span class="p">]</span>

    <span class="nd">@_check_length</span>
    <span class="k">def</span> <span class="nf">set_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">rg</span><span class="o">.</span><span class="n">_ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>

<div class="viewcode-block" id="ResidueAttr.get_segments"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.ResidueAttr.get_segments">[docs]</a>    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;By default, the values for each residue present in the set of</span>
<span class="sd">        segments are returned in a single array. This behavior can be overriden</span>
<span class="sd">        in child attributes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rixs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">segments2residues_2d</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">_ix</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">rix</span><span class="p">]</span> <span class="k">for</span> <span class="n">rix</span> <span class="ow">in</span> <span class="n">rixs</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">set_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">_wronglevel_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">)</span></div>


<span class="c1"># TODO: update docs to property doc</span>
<div class="viewcode-block" id="Resids"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Resids">[docs]</a><span class="k">class</span> <span class="nc">Resids</span><span class="p">(</span><span class="n">ResidueAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Residue ID&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;resids&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;resid&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">]</span></div>


<span class="c1"># TODO: update docs to property doc</span>
<span class="k">class</span> <span class="nc">Resnames</span><span class="p">(</span><span class="n">ResidueAttr</span><span class="p">):</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;resnames&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;resname&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">]</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getattr__</span><span class="p">(</span><span class="n">residuegroup</span><span class="p">,</span> <span class="n">resname</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">residuegroup</span><span class="o">.</span><span class="n">_get_named_residue</span><span class="p">(</span><span class="n">resname</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">selection</span><span class="o">.</span><span class="n">SelectionError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{0}</span><span class="s2">&#39; object has no attribute &#39;</span><span class="si">{1}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">residuegroup</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">resname</span><span class="p">))</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">ResidueGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;__getattr__&#39;</span><span class="p">,</span> <span class="n">getattr__</span><span class="p">))</span>
    <span class="c1"># This transplant is hardcoded for now to allow for multiple getattr things</span>
    <span class="c1">#transplants[Segment].append((&#39;__getattr__&#39;, getattr__))</span>

    <span class="k">def</span> <span class="nf">_get_named_residue</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">resname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get all residues with name *resname* in the current ResidueGroup</span>
<span class="sd">        or Segment.</span>

<span class="sd">        For more than one residue it returns a</span>
<span class="sd">        :class:`MDAnalysis.core.groups.ResidueGroup` instance. A single</span>
<span class="sd">        :class:`MDAnalysis.core.group.Residue` is returned for a single match.</span>
<span class="sd">        If no residues are found, a :exc:`SelectionError` is raised.</span>

<span class="sd">        .. versionadded:: 0.9.2</span>

<span class="sd">        .. deprecated:: 0.16.2</span>
<span class="sd">           *Instant selectors* will be removed in the 1.0 release.</span>
<span class="sd">           Use ``ResidueGroup[ResidueGroup.resnames == &#39;&lt;name&gt;&#39;]``</span>
<span class="sd">           or ``Segment.residues[Segment.residues == &#39;&lt;name&gt;&#39;]``</span>
<span class="sd">           instead.</span>
<span class="sd">           See issue `#1377</span>
<span class="sd">           &lt;https://github.com/MDAnalysis/mdanalysis/issues/1377&gt;`_ for</span>
<span class="sd">           more details.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># There can be more than one residue with the same name</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">residues</span><span class="o">.</span><span class="n">unique</span><span class="p">[</span>
                <span class="n">group</span><span class="o">.</span><span class="n">residues</span><span class="o">.</span><span class="n">unique</span><span class="o">.</span><span class="n">resnames</span> <span class="o">==</span> <span class="n">resname</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">residues</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">selection</span><span class="o">.</span><span class="n">SelectionError</span><span class="p">(</span>
                <span class="s2">&quot;No residues with resname &#39;</span><span class="si">{0}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">resname</span><span class="p">))</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Instant selector ResidueGroup.&lt;name&gt; &quot;</span>
                      <span class="s2">&quot;or Segment.&lt;name&gt; &quot;</span>
                      <span class="s2">&quot;is deprecated and will be removed in 1.0. &quot;</span>
                      <span class="s2">&quot;Use ResidueGroup[ResidueGroup.resnames == &#39;&lt;name&gt;&#39;] &quot;</span>
                      <span class="s2">&quot;or Segment.residues[Segment.residues == &#39;&lt;name&gt;&#39;] &quot;</span>
                      <span class="s2">&quot;instead.&quot;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">residues</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># XXX: keep this, makes more sense for names</span>
            <span class="k">return</span> <span class="n">residues</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># XXX: but inconsistent (see residues and Issue 47)</span>
            <span class="k">return</span> <span class="n">residues</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">ResidueGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;_get_named_residue&#39;</span><span class="p">,</span> <span class="n">_get_named_residue</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the amino acid sequence.</span>

<span class="sd">        The format of the sequence is selected with the keyword *format*:</span>

<span class="sd">        ============== ============================================</span>
<span class="sd">        *format*       description</span>
<span class="sd">        ============== ============================================</span>
<span class="sd">        &#39;SeqRecord&#39;    :class:`Bio.SeqRecord.SeqRecord` (default)</span>
<span class="sd">        &#39;Seq&#39;          :class:`Bio.Seq.Seq`</span>
<span class="sd">        &#39;string&#39;       string</span>
<span class="sd">        ============== ============================================</span>

<span class="sd">        The sequence is returned by default (keyword ``format = &#39;SeqRecord&#39;``)</span>
<span class="sd">        as a :class:`Bio.SeqRecord.SeqRecord` instance, which can then be</span>
<span class="sd">        further processed. In this case, all keyword arguments (such as the</span>
<span class="sd">        *id* string or the *name* or the *description*) are directly passed to</span>
<span class="sd">        :class:`Bio.SeqRecord.SeqRecord`.</span>

<span class="sd">        If the keyword *format* is set to ``&#39;Seq&#39;``, all *kwargs* are ignored</span>
<span class="sd">        and a :class:`Bio.Seq.Seq` instance is returned. The difference to the</span>
<span class="sd">        record is that the record also contains metadata and can be directly</span>
<span class="sd">        used as an input for other functions in :mod:`Bio`.</span>

<span class="sd">        If the keyword *format* is set to ``&#39;string&#39;``, all *kwargs* are</span>
<span class="sd">        ignored and a Python string is returned.</span>

<span class="sd">        .. rubric:: Example: Write FASTA file</span>

<span class="sd">        Use :func:`Bio.SeqIO.write`, which takes sequence records::</span>

<span class="sd">           import Bio.SeqIO</span>

<span class="sd">           # get the sequence record of a protein component of a Universe</span>
<span class="sd">           protein = u.select_atoms(&quot;protein&quot;)</span>
<span class="sd">           record = protein.sequence(id=&quot;myseq1&quot;, name=&quot;myprotein&quot;)</span>

<span class="sd">           Bio.SeqIO.write(record, &quot;single.fasta&quot;, &quot;fasta&quot;)</span>

<span class="sd">        A FASTA file with multiple entries can be written with ::</span>

<span class="sd">           Bio.SeqIO.write([record1, record2, ...], &quot;multi.fasta&quot;, &quot;fasta&quot;)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        format : string, optional</span>
<span class="sd">           - ``&quot;string&quot;``: return sequence as a string of 1-letter codes</span>
<span class="sd">           - ``&quot;Seq&quot;``: return a :class:`Bio.Seq.Seq` instance</span>
<span class="sd">           - ``&quot;SeqRecord&quot;``: return a :class:`Bio.SeqRecord.SeqRecord`</span>
<span class="sd">             instance</span>

<span class="sd">            Default is ``&quot;SeqRecord&quot;``</span>
<span class="sd">        id : optional</span>
<span class="sd">           Sequence ID for SeqRecord (should be different for different</span>
<span class="sd">           sequences)</span>
<span class="sd">        name : optional</span>
<span class="sd">           Name of the protein.</span>
<span class="sd">        description : optional</span>
<span class="sd">           Short description of the sequence.</span>
<span class="sd">        kwargs : optional</span>
<span class="sd">           Any other keyword arguments that are understood by</span>
<span class="sd">           class:`Bio.SeqRecord.SeqRecord`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        :exc:`ValueError` if a residue name cannot be converted to a</span>
<span class="sd">        1-letter IUPAC protein amino acid code; make sure to only</span>
<span class="sd">        select protein residues.</span>

<span class="sd">        :exc:`TypeError` if an unknown *format* is selected.</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">formats</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;string&#39;</span><span class="p">,</span> <span class="s1">&#39;Seq&#39;</span><span class="p">,</span> <span class="s1">&#39;SeqRecord&#39;</span><span class="p">)</span>

        <span class="nb">format</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;format&quot;</span><span class="p">,</span> <span class="s2">&quot;SeqRecord&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">formats</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unknown format=&#39;</span><span class="si">{0}</span><span class="s2">&#39;: must be one of: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">format</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">formats</span><span class="p">)))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sequence</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">convert_aa_code</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">residues</span><span class="o">.</span><span class="n">resnames</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;AtomGroup contains a residue name &#39;</span><span class="si">{0}</span><span class="s2">&#39; that &quot;</span>
                             <span class="s2">&quot;does not have a IUPAC protein 1-letter &quot;</span>
                             <span class="s2">&quot;character&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="n">message</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;string&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sequence</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="n">Bio</span><span class="o">.</span><span class="n">Seq</span><span class="o">.</span><span class="n">Seq</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="n">Bio</span><span class="o">.</span><span class="n">Alphabet</span><span class="o">.</span><span class="n">IUPAC</span><span class="o">.</span><span class="n">protein</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;Seq&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">seq</span>
        <span class="k">return</span> <span class="n">Bio</span><span class="o">.</span><span class="n">SeqRecord</span><span class="o">.</span><span class="n">SeqRecord</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">ResidueGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;sequence&#39;</span><span class="p">,</span> <span class="n">sequence</span><span class="p">))</span>


<span class="c1"># TODO: update docs to property doc</span>
<span class="k">class</span> <span class="nc">Resnums</span><span class="p">(</span><span class="n">ResidueAttr</span><span class="p">):</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;resnums&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;resnum&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">]</span>


<div class="viewcode-block" id="ICodes"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.ICodes">[docs]</a><span class="k">class</span> <span class="nc">ICodes</span><span class="p">(</span><span class="n">ResidueAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Insertion code for Atoms&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;icodes&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;icode&#39;</span></div>


<span class="c1"># segment attributes</span>

<div class="viewcode-block" id="SegmentAttr"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.SegmentAttr">[docs]</a><span class="k">class</span> <span class="nc">SegmentAttr</span><span class="p">(</span><span class="n">TopologyAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for segment attributes.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;segmentattrs&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;segmentattr&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Segment</span><span class="p">]</span>
    <span class="n">per_object</span> <span class="o">=</span> <span class="s1">&#39;segment&#39;</span>

    <span class="k">def</span> <span class="nf">get_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="n">six</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">atoms2segments</span><span class="p">(</span><span class="n">ag</span><span class="o">.</span><span class="n">_ix</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">six</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">set_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">_wronglevel_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="n">six</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">tt</span><span class="o">.</span><span class="n">residues2segments</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">_ix</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">six</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">set_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">_wronglevel_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">sg</span><span class="o">.</span><span class="n">_ix</span><span class="p">]</span>

    <span class="nd">@_check_length</span>
    <span class="k">def</span> <span class="nf">set_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">sg</span><span class="o">.</span><span class="n">_ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span></div>


<span class="c1"># TODO: update docs to property doc</span>
<span class="k">class</span> <span class="nc">Segids</span><span class="p">(</span><span class="n">SegmentAttr</span><span class="p">):</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;segids&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;segid&#39;</span>
    <span class="n">target_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Atom</span><span class="p">,</span> <span class="n">Residue</span><span class="p">,</span> <span class="n">Segment</span><span class="p">]</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getattr__</span><span class="p">(</span><span class="n">segmentgroup</span><span class="p">,</span> <span class="n">segid</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">segmentgroup</span><span class="o">.</span><span class="n">_get_named_segment</span><span class="p">(</span><span class="n">segid</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">selection</span><span class="o">.</span><span class="n">SelectionError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{0}</span><span class="s2">&#39; object has no attribute &#39;</span><span class="si">{1}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">segmentgroup</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">segid</span><span class="p">))</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">SegmentGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;__getattr__&#39;</span><span class="p">,</span> <span class="n">getattr__</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_named_segment</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">segid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get all segments with name *segid* in the current SegmentGroup.</span>

<span class="sd">        For more than one residue it returns a</span>
<span class="sd">        :class:`MDAnalysis.core.groups.SegmentGroup` instance. A single</span>
<span class="sd">        :class:`MDAnalysis.core.group.Segment` is returned for a single match.</span>
<span class="sd">        If no residues are found, a :exc:`SelectionError` is raised.</span>

<span class="sd">        .. versionadded:: 0.9.2</span>

<span class="sd">        .. deprecated:: 0.16.2</span>
<span class="sd">           *Instant selectors* will be removed in the 1.0 release.</span>
<span class="sd">           Use ``SegmentGroup[SegmentGroup.segids == &#39;&lt;name&gt;&#39;]`` instead.</span>
<span class="sd">           See issue `#1377</span>
<span class="sd">           &lt;https://github.com/MDAnalysis/mdanalysis/issues/1377&gt;`_ for</span>
<span class="sd">           more details.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Undo adding &#39;s&#39; if segid started with digit</span>
        <span class="k">if</span> <span class="n">segid</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">segid</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">segid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="n">segid</span> <span class="o">=</span> <span class="n">segid</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># There can be more than one segment with the same name</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">segments</span><span class="o">.</span><span class="n">unique</span><span class="p">[</span>
                <span class="n">group</span><span class="o">.</span><span class="n">segments</span><span class="o">.</span><span class="n">unique</span><span class="o">.</span><span class="n">segids</span> <span class="o">==</span> <span class="n">segid</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">selection</span><span class="o">.</span><span class="n">SelectionError</span><span class="p">(</span>
                <span class="s2">&quot;No segments with segid &#39;</span><span class="si">{0}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">segid</span><span class="p">))</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Instant selector SegmentGroup.&lt;name&gt; &quot;</span>
                      <span class="s2">&quot;is deprecated and will be removed in 1.0. &quot;</span>
                      <span class="s2">&quot;Use SegmentGroup[SegmentGroup.segids == &#39;&lt;name&gt;&#39;] &quot;</span>
                      <span class="s2">&quot;instead.&quot;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># XXX: keep this, makes more sense for names</span>
            <span class="k">return</span> <span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># XXX: but inconsistent (see residues and Issue 47)</span>
            <span class="k">return</span> <span class="n">segments</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">SegmentGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;_get_named_segment&#39;</span><span class="p">,</span> <span class="n">_get_named_segment</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">_Connection</span><span class="p">(</span><span class="n">AtomAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for connectivity between atoms&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">types</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="n">types</span>
        <span class="k">if</span> <span class="n">guessed</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="c1"># if single value passed, multiply this across</span>
            <span class="c1"># all bonds</span>
            <span class="n">guessed</span> <span class="o">=</span> <span class="p">[</span><span class="n">guessed</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span> <span class="o">=</span> <span class="n">guessed</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bondDict</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@cached</span><span class="p">(</span><span class="s1">&#39;bd&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_bondDict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Lazily built mapping of atoms:bonds&quot;&quot;&quot;</span>
        <span class="n">bd</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">):</span>
            <span class="c1"># We always want the first index</span>
            <span class="c1"># to be less than the last</span>
            <span class="c1"># eg (0, 1) not (1, 0)</span>
            <span class="c1"># and (4, 10, 8) not (8, 10, 4)</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">bd</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">o</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">bd</span>

    <span class="k">def</span> <span class="nf">set_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="k">return</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Cannot set bond information&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ag</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">unique_bonds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
                <span class="o">*</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_bondDict</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ag</span><span class="o">.</span><span class="n">_ix</span><span class="p">]))</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># maybe we got passed an Atom</span>
            <span class="n">unique_bonds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bondDict</span><span class="p">[</span><span class="n">ag</span><span class="o">.</span><span class="n">_ix</span><span class="p">]</span>
        <span class="n">bond_idx</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">guessed</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hsplit</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">unique_bonds</span><span class="p">)),</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">bond_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bond_idx</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">types</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">guessed</span> <span class="o">=</span> <span class="n">guessed</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">TopologyGroup</span><span class="p">(</span><span class="n">bond_idx</span><span class="p">,</span> <span class="n">ag</span><span class="o">.</span><span class="n">_u</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">singular</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                             <span class="n">types</span><span class="p">,</span>
                             <span class="n">guessed</span><span class="p">,</span>
                             <span class="n">order</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">guessed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">types</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">types</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">((</span><span class="kc">None</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">guessed</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">guessed</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">((</span><span class="n">guessed</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">((</span><span class="kc">None</span><span class="p">,))</span>

        <span class="n">existing</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">guessed</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">existing</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_guessed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="c1"># kill the old cache of bond Dict</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="s1">&#39;bd&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>


<div class="viewcode-block" id="Bonds"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Bonds">[docs]</a><span class="k">class</span> <span class="nc">Bonds</span><span class="p">(</span><span class="n">_Connection</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Bonds between two atoms</span>

<span class="sd">    Must be initialised by a list of zero based tuples.</span>
<span class="sd">    These indices refer to the atom indices.</span>
<span class="sd">    E.g., ` [(0, 1), (1, 2), (2, 3)]`</span>

<span class="sd">    Also adds the `bonded_atoms`, `fragment` and `fragments`</span>
<span class="sd">    attributes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;bonds&#39;</span>
    <span class="c1"># Singular is the same because one Atom might have</span>
    <span class="c1"># many bonds, so still asks for &quot;bonds&quot; in the plural</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;bonds&#39;</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

<div class="viewcode-block" id="Bonds.bonded_atoms"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Bonds.bonded_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">bonded_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An AtomGroup of all atoms bonded to this Atom&quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">partner</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonds</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_u</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>

    <span class="n">transplants</span><span class="p">[</span><span class="n">Atom</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;bonded_atoms&#39;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">bonded_atoms</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                                  <span class="n">bonded_atoms</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)))</span>

<div class="viewcode-block" id="Bonds.fragment"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Bonds.fragment">[docs]</a>    <span class="k">def</span> <span class="nf">fragment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The fragment that this Atom is part of</span>

<span class="sd">        .. versionadded:: 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">_fragdict</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span></div>

<div class="viewcode-block" id="Bonds.fragments"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Bonds.fragments">[docs]</a>    <span class="k">def</span> <span class="nf">fragments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read-only list of fragments.</span>

<span class="sd">        Contains all fragments that any Atom in this AtomGroup is</span>
<span class="sd">        part of, the contents of the fragments may extend beyond the</span>
<span class="sd">        contents of this AtomGroup.</span>

<span class="sd">        .. versionadded 0.9.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">fragment</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">),</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
        <span class="p">))</span></div>

    <span class="n">transplants</span><span class="p">[</span><span class="n">Atom</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;fragment&#39;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">fragment</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="n">fragment</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)))</span>

    <span class="n">transplants</span><span class="p">[</span><span class="n">AtomGroup</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;fragments&#39;</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">fragments</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="n">fragments</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)))</span></div>


<div class="viewcode-block" id="Angles"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Angles">[docs]</a><span class="k">class</span> <span class="nc">Angles</span><span class="p">(</span><span class="n">_Connection</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Angles between three atoms</span>

<span class="sd">    Initialise with a list of 3 long tuples</span>
<span class="sd">    E.g.,  `[(0, 1, 2), (1, 2, 3), (2, 3, 4)]`</span>

<span class="sd">    These indices refer to the atom indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;angles&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;angles&#39;</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dihedrals"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Dihedrals">[docs]</a><span class="k">class</span> <span class="nc">Dihedrals</span><span class="p">(</span><span class="n">_Connection</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A connection between four sequential atoms&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;dihedrals&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;dihedrals&#39;</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span></div>


<div class="viewcode-block" id="Impropers"><a class="viewcode-back" href="../../../documentation_pages/core/topologyattrs.html#MDAnalysis.core.topologyattrs.Impropers">[docs]</a><span class="k">class</span> <span class="nc">Impropers</span><span class="p">(</span><span class="n">_Connection</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An imaginary dihedral between four atoms&quot;&quot;&quot;</span>
    <span class="n">attrname</span> <span class="o">=</span> <span class="s1">&#39;impropers&#39;</span>
    <span class="n">singular</span> <span class="o">=</span> <span class="s1">&#39;impropers&#39;</span>
    <span class="n">transplants</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/logos/mdanalysis-logo-200x150.png" alt="Logo"/>
    
  </a>
</p>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=MDAnalysis&repo=mdanalysis&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





    

<p>
<a href="https://travis-ci.org/MDAnalysis/mdanalysis">
    <img
        alt="https://secure.travis-ci.org/MDAnalysis/mdanalysis.svg?branch=master"
        src="https://secure.travis-ci.org/MDAnalysis/mdanalysis.svg?branch=master"
    />
</a>
</p>


<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/overview.html">1. Overview over MDAnalysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/topology.html">2. The topology system</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/selections.html">3. Selection commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/analysis_modules.html">4. Analysis modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/topology_modules.html">5. Topology modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/coordinates_modules.html">6. Coordinates modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/selections_modules.html">7. Selection exporters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/auxiliary_modules.html">8. Auxiliary modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/core_modules.html">9. Core modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/visualization_modules.html">10. Visualization modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/lib_modules.html">11. Library functions &#8212; <code class="docutils literal"><span class="pre">MDAnalysis.lib</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/version.html">12. Version information for MDAnalysis - <code class="docutils literal"><span class="pre">MDAnalysis.version</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/units.html">13. Constants and unit conversion &#8212; <code class="docutils literal"><span class="pre">MDAnalysis.units</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/exceptions.html">14. Custom exceptions and warnings &#8212; <code class="docutils literal"><span class="pre">MDAnalysis.exceptions</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../documentation_pages/references.html">15. References</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2005-2017, Naveen Michaud-Agrawal, Elizabeth J. Denning, Christian Beckstein (logo), Joshua L. Adelman, Shobhit Agarwal, Balasubramanian, Utkarsh Bansal, Jonathan Barnoud, Tone Bengtsen, Alejandro Bernardin, Wouter Boomsma, Bart Bruininks, Sébastien Buchoux, David Caplan, Matthieu Chavent, Kathleen Clark, Robert Delgado, John Detlefs, Xavier Deupi, Jan Domanski, David L. Dotson, Lennard van der Feltz, Philip Fowler, Joseph Goose, Richard J. Gowers, Lukas Grossar, Abhinav Gupta, Akshay Gupta, Benjamin Hall, Eugen Hruska, Kyle J. Huston, Joe Jordan, Jon Kapla, Andrew William King, Max Linke, Jinju Lu, Robert McGibbon, Manuel Nuno Melo, Dominik 'Rathann' Mierzejewski, Fiona Naughton, Alex Nesterenko, Hai Nguyen, Sang Young Noh, Mattia F. Palermo, Danny Parton, Joshua L. Phillips, Vedant Rathore, Tyler Reddy, Paul Rigor, Carlos Yanez S., Utkarsh Saxena, Sean L. Seyler, Andy Somogyi, Caio S. Souza, Shantanu Srivastava, Lukas Stelzl, Gorman Stock, Xiki Tempula, Matteo Tiberti, Isaac Virshup, Zhuyi Xue, Juan Eiros Zamora, and Oliver Beckstein.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    
    <a href="https://github.com/MDAnalysis/mdanalysis" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>